<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
      <title>Idyll</title>
      <meta property="og:title" content="Idyll Project">
    <meta charset="utf-8">
    <meta property="og:type" content="article">

    <link rel="stylesheet" href="styles.css">
  </head>
  <body>
    <div id="idyll-mount"><div class="idyll-root" data-reactroot=""><div class="article-header"><div class="article-header__content"><h1 class="hed">Things I Learned the Hard Way Using React Native</h1><div class="byline"><a href="https://github.com/rreusser">Ricky Reusser</a></div><div class="published-at">May 5, 2016</div></div></div><div class=" idyll-text-container"><h2>the tl;dr:</h2><p>This post exists because I wish someone had sat me down and told me half of these things on Day One of using React Native.</p><h2>The kinda long; might read:</h2><p>I am decidedly not an expert in <a href="http://facebook.github.io/react-native/">React Native</a>, but that doesnâ€™t mean I havenâ€™t learned a lot of difficult lessons over the last <a href="http://www.thefoodstand.com">eight months</a>. And earlier today I had the chance to introduce a couple developers to React Native. They had JavaScript experience and knew their way around mobile apps, but React Native was a new beast. It made me recall what a foreign set of concepts <a href="https://facebook.github.io/react/">React</a> and <a href="facebook.github.io/react-native">React Native</a> were when we started out.</p><p>This post is a loose collection of the things I wish someone had just told me from the beginning. Some are obvious; some arenâ€™t. The original gist is <a href="https://gist.github.com/rreusser/c673bb3ec5316cf3bd46a18d4777eff3">here</a>. Iâ€™ve surely missed a lot of good information. So itâ€™s not everything, but hopefully itâ€™s mostly valid information that can save someone else some of the time it took us to discover all of these things. If thereâ€™s something thatâ€™s changed your life (dev-wise), please let me know in the comments section and Iâ€™d be glad to add it to the list!</p><p><em>Update:</em> Great recommendations based on twitter replies/searches (Thanks, <a href="https://twitter.com/sseraphini">sseraphini</a>!):</p><ul><li><a href="https://github.com/yelouafi/redux-saga">redux-saga</a></li><li><a href="https://github.com/gaearon/redux-thunk">redux-thunk</a></li><li><a href="https://github.com/lelandrichardson/react-native-mock">react-native-mock</a></li><li><a href="https://github.com/airbnb/enzyme">enzyme</a></li><li><a href="https://twitter.com/JI/status/728696866343243777">Sentry and Crashlytics</a></li></ul><h2>The thoughts:</h2><p><strong>Set up your environment carefully</strong>: Itâ€™s important to have <em>one</em> canonical source of truth per environment, per platform. (i.e. iOS Development, iOS Testflight, iOS Production, ditto Android.) Every time you build, your config should propagate values from one input source (per env) to either Java/JavaScript or Objective-C/JavaScript. <a href="https://gist.github.com/rreusser/77c18ca38a6848876c22a00d3fed99a9">Hereâ€™s what we did for Android</a> and <a href="https://gist.github.com/rreusser/283e032fb1bb5f59256fd5b96f8b8e6c">hereâ€™s what we did for iOS</a>. I donâ€™t doubt that you can do better. <em>Please do better.</em> But you canâ€™t say that we didnâ€™t have one canonical source of truth that worked very simply and effectively throughout the development process.</p><p><strong>Donâ€™t wait until the end to develop Android and iOS concurrently:</strong> Even if youâ€™re not actively focusing on both platforms, donâ€™t assume that â€œRN is cross platformâ€¦ we can develop iOS and flip the Android switch when weâ€™re done.â€ Itâ€™s mostly cross-platform. But thereâ€™s lots of little stuff like iOS and Android handling margins on text differently. Small quirks, but not the sort of stuff you want to completely refactor at the end.</p><p><strong>Use a linter:</strong> I like <a href="https://github.com/Flet/semistandard">semistandard</a>. We ran into lots of frustrating issues where we had duplicate keys in hashes that didnâ€™t fail until we moved to the web platform. A linter can be annoying, but itâ€™s not so bad if you get on board early. Prevents you from doing lots of stupid invalid stuff that doesnâ€™t actually cause errors.</p><p><strong>Learning Redux</strong>: If you use it. It was useful to read the source itself. Itâ€™s actually relatively concise. <a href="https://gist.github.com/gaearon/1d19088790e70ac32ea636c025ba424e#file-connect-js">Hereâ€™s Dan Abramov deconstructing it</a>. It helped clear up my understanding of whatâ€™s going on. Understanding exactly why components get updated helped us improve performance dramatically. <a href="https://github.com/reactjs/react-redux/blob/master/src/components/connect.js#L283">I think these are the lines that do it in redux</a>. (<em>&lt;-- fixed this link because hadnâ€™t looked at this in a while and so didnâ€™t look deep enough</em>). As for connecting components, we debated whether to connect giant parts of the state tree or lots of little values. Also whether to connect tons of little components or just the big components. Short answer: understand why things get re-rendered and a happy medium is probably best because either extreme has tradeoffs. Connecting <strong>every</strong> component seems silly and expensive, and itâ€™s probably overkill and unnecessarily verbose to unpack tons of values in every <code>mapStateToProps</code>. Happy medium, I think.</p><p><strong>But whatâ€™s the right data store???</strong><em>The right data store is one that you understand.</em> We stored our stuff in some weird key-value store (for historical reasons, a glorified <code>{users: {...}, ...}</code> object). It worked pretty well, but what would have made it better would have been either to understand better what triggers updates from the start or maybe to take the plunge and get on board with immutablejs from the start. But thereâ€™s no one true answer. Ours worked fine. If you use a library for your datastore, mainly try to understand <em>why</em> it does what it does (which doesnâ€™t necessarily include worrying about the internal workings). So just pick one. Donâ€™t worry. <a href="http://techcrunch.com/2014/10/18/you-too-may-be-a-victim-of-developaralysis/">Youâ€™ll be fine</a>.</p><p><strong>Put `console.logs` in your render statements and figure out just how often things are getting rendered.</strong> You can get away with a lot for a while using react. Itâ€™s magic. Until it feels laggy. The second major release of our iOS app was mainly a giant audit of why there was so much extra rendering going on. Performance increased dramatically.</p><p><strong>Follow people on twitter:</strong><a href="https://twitter.com/dan_abramov">@dan\_abramov</a>, <a href="https://twitter.com/JI">@JI</a>, <a href="https://twitter.com/ReactJSNews">@ReactJSNews</a>, <a href="https://twitter.com/Vjeux">@Vjeux</a>. Lots more. A good way to be a fly on the wall and find out about trendy stuff without getting sucked into a hacker-news sort of rabbit hole.</p><p><strong>React universal template</strong> The future is upon us. Web, iOS, Android, Server. One codebase. And Windows Phone, soonish. <a href="https://github.com/este/este">este/este.js</a></p><p><strong>My template</strong> which isnâ€™t great but maybe has a couple things going for it regarding redux + immutable setup. Generally speaking, donâ€™t just copy the setup blindly though. Understand it. <a href="https://github.com/rreusser/react-native-with-everything">react-native-with-everything</a></p><p><strong>Live on the bleeding edge</strong>: Itâ€™s a calculated risk when youâ€™re trying to run a business, but we never got bitten by upgrading early and often. On the contrary, the bugfixes and frequent updates prevented our code from getting stale. It meant submitting lots of little PRs to different repos, but it was time well spent. When the community indicates the direction theyâ€™re going, take a hint. So yeah, itâ€™s probably all NavigatorExperimental moving forward.</p><p><strong>This stuff is outstanding</strong>:</p><ul><li><a href="https://github.com/oblador/react-native-animatable">oblador/react-native-animatable</a></li><li><a href="https://github.com/oblador/react-native-vector-icons">oblador/react-native-vector-icons</a></li></ul><p><strong>Corollary</strong>: <a href="https://icomoon.io/">icomoon.io</a> is the best thing ever for managing icons.</p><p><strong>We didnâ€™t do much testing.</strong> There. I said it. We didnâ€™t do much testing. It felt horrible. Iâ€™m embarrassed. There are some little unit tests for tricky logic, and the server-side code has pretty good coverage, but thereâ€™s not really any mobile integration testing. Honestly, good redux middleware made debugging and reasoning about state so easy that there was just never a time when it was a top priority to lock down functionality with tests before we ripped features out and replaced them. We had a couple minor regressions, but 80% of the challenges we had were obscure, untestable things like a weird layering bug with the twitter native share dialog. (And once we hooked up <a href="https://microsoft.github.io/code-push/">CodePush</a>, we could <a href="https://www.youtube.com/watch?v=O_HyZ5aW76c">do it live</a> anyway.) That said, you should always test your code. ğŸ˜ŠğŸ‘ğŸ¼</p><p><strong>Keyboard spacer</strong>: I <em>highly</em> recommend a single keyboard spacer at the bottom of your top-level view. Or at least very few as high up in the DOM as possible. No need to add them all over the place (itâ€™s a mess), and best to avoid fixing the height of anything to the height of the viewport (Android and the in-call status bar will make your life unpleasant).<a href="https://www.npmjs.com/package/react-native-keyboard-spacer">react-native-keyboard-spacer</a></p><p><strong>Steer clear of negative margins.</strong> On iOS itâ€™s the same useful trick you web devs are used to. On Android (unless thereâ€™s a trick I wasnâ€™t able to find), they all get clipped. If you want content to sit outside its parent container, use a larger parent container with <a href="http://facebook.github.io/react-native/docs/view.html#pointerevents">`pointerEvents=â€œbox-noneâ€`</a>.</p><p><strong>Margins and padding on text components</strong> more or less donâ€™t have much of an effect on Android, so really try to avoid them if you start with iOS!</p><p><strong>Higher order components</strong> (enhancing behavior without mixins or class inheritance):<a href="https://gist.github.com/sebmarkbage/ef0bf1f338a7182b6775">https://gist.github.com/sebmarkbage/ef0bf1f338a7182b6775</a></p><p><strong>This is useful</strong>: Premature optimization is bad, but good to get a handle on what optimization means: <a href="https://github.com/garbles/why-did-you-update">garbles/why-did-you-update</a></p><p><strong><a href="https://facebook.github.io/react/blog/2015/10/07/react-v0.14.html#stateless-functional-components">Stateless functional components</a></strong>: Good for components that can have no internal state.</p><pre style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code><span style="color:#c678dd">var</span> Button = <span>(<span>props</span>) =&gt;</span> {
  <span style="color:#c678dd">return</span> &lt;View&gt;&lt;Text&gt;{props.label}&lt;/Text&gt;&lt;/View&gt;
}</code></pre><p><strong>But be careful with those because:</strong> An interesting discussion on avoiding re-rendering the entire app on every state update: <a href="https://medium.com/@esamatti/react-js-pure-render-performance-anti-pattern-fb88c101332f#.u3tqgdf47">Pure Render Performance Anti-Pattern</a></p><p><strong>Or just forget understanding optimization and use this:</strong> ğŸ˜„</p><ul><li><a href="https://github.com/thejameskyle/babel-react-optimize">thejameskyle/babel-react-optimize</a></li></ul><p><strong>A trivial optimization that may actually be noticable</strong>:</p><p>Instead of this:</p><pre style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code><span style="color:#c678dd">return</span> &lt;TextInput onChange={() =&gt; { do something inline}}/&gt;</code></pre><p>Do this:</p><pre style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code>_handleChange = <span><span>()</span> =&gt;</span> {
  same thing but not inline
};

render () {
  <span style="color:#c678dd">return</span> &lt;TextInput onChange={this._handleChange}/&gt;
}</code></pre><p>Subtle, but (and thanks, Scott Kyle for correcting my obvious oversight on this one!!) in the first version, the <code>TextInput</code> gets a new callback every time and so gets re-rendered. The second passes the reference to the same callback, hence no re-render.</p><strong>Rendering arrays:</strong><p>Except for the final <code>render</code> which needs to return a single node, you can always deal with arrays of keyed nodes instead of jamming everything together into wrapper views all over the place, e.g.:</p><pre style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code>renderSomePart = <span><span>()</span> =&gt;</span> {
  <span style="color:#c678dd">return</span> [
    &lt;View key=â€œitem-1â€/&gt;,
    &lt;View key=â€œitem-2â€³/&gt;
  ];
};</code></pre><p>Or:</p><pre style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code>renderItem = <span>(<span>item, i</span>) =&gt;</span> (
  &lt;View key=`item-${i}`&gt; ... &lt;/View&gt;
)

renderSomePart = <span><span>()</span> =&gt;</span> {
  <span style="color:#c678dd">return</span> <span style="color:#c678dd">this</span>.props.someDataItems.map(<span style="color:#c678dd">this</span>.renderItem);
};</code></pre><p>And text nodes can contain other text nodes. Our first attempt at a paragraph with mentions was to split text by whitespace and lay out nodes with flexbox. Thatâ€™s crazy. You can just nest text nodes and make some of them pressable. Sounds obscure, but it wasnâ€™t immediately obvious, and if you need it, itâ€™s life-changing.</p><pre style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code>render () {
  <span style="color:#c678dd">return</span> &lt;View&gt;{[
    &lt;Text key=â€œ1â€&gt;Hello, &lt;/Text&gt;,
    &lt;Text key=â€œ2â€³&gt;{[
      &lt;Text key=â€œ3â€ onPress={...}&gt;this is a link&lt;/Text&gt;,
      &lt;Text key=â€œ4â€³&gt;, and this is just regular text&lt;/Text&gt;
    ]}&lt;/Text&gt;
  ]}&lt;/View&gt;;
}</code></pre><p><strong>Loading overlays and z-ordering:</strong>
Absolutely position the overlay top/right/left/bottom: 0 and make sure itâ€™s <em>after</em> the rest of the content it needs to overlay. Draw order is last-on-top:</p><pre style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code>&lt;View&gt;
  &lt;...&gt;
  &lt;LoadingOverlay&gt;
&lt;/View&gt;</code></pre><p><strong>Android installation (Genymotion)</strong>
Ommitted for brevity, but you can see it in the original gist <a href="https://gist.github.com/rreusser/c673bb3ec5316cf3bd46a18d4777eff3">here</a>. Android Studio 2.0 seems better these days though. Great emulator.</p><h2>Conclusion</h2><p>Thatâ€™s all for now! At the end here, Iâ€™m clearly kinda scraping the bottom of the barrel. Thereâ€™s nothing profound here, but talking to new React Native devs made me realize how much time we could have saved if someone had been there to walk us through a few basics and warn us ahead of time where weâ€™d dig the deepest holes for ourselves. Overall we had nothing but good fortune to have taken a gamble and found ourselves working among an oustanding, welcoming, active community of developers. If you need a mobile platform, I highly recomend that you <a href="http://facebook.github.io/react-native/">give it a try!</a></p></div></div></div>
    <script src="index.js"></script>
  </body>
</html>
