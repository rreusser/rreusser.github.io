<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
      <title>
        Things I Learned the Hard Way Using React Native
      </title>
      <meta property="og:title" content="Things I Learned the Hard Way Using React Native">
    <meta charset="utf-8">
    <meta property="og:type" content="article">

      <meta property="og:description" content="A post which exists because I wish someone had sat me down and told me half of these things on Day One of using React Native.">
      <meta property="description" content="A post which exists because I wish someone had sat me down and told me half of these things on Day One of using React Native.">
    <link rel="stylesheet" href="../styles.css">
  </head>
  <body>
    <div id="idyll-mount"><div data-reactroot=""><div class="idyll-root"><nav class="menu"><a class="menu__item" href="/">rreusser.github.io</a><a class="menu__item" href="/sketches/">sketches</a><a class="menu__item" href="/projects/">projects</a></nav><div class="article-header"><div class="article-header__content"><h1 class="hed">Things I Learned the Hard Way Using React Native</h1><div class="byline"><a href="https://github.com/rreusser">Ricky Reusser</a></div><div class="published-at">May 5, 2016</div></div></div><div class=" idyll-text-container"><h2>the tl;dr:</h2><p>This post exists because I wish someone had sat me down and told me half of these things on Day One of using React Native.</p><h2>The kinda long; might read:</h2><p>I am decidedly not an expert in <a href="http://facebook.github.io/react-native/">React Native</a>, but that doesn‚Äôt mean I haven‚Äôt learned a lot of difficult lessons over the last <a href="http://www.thefoodstand.com">eight months</a>. And earlier today I had the chance to introduce a couple developers to React Native. They had JavaScript experience and knew their way around mobile apps, but React Native was a new beast. It made me recall what a foreign set of concepts <a href="https://facebook.github.io/react/">React</a> and <a href="facebook.github.io/react-native">React Native</a> were when we started out.</p><p>This post is a loose collection of the things I wish someone had just told me from the beginning. Some are obvious; some aren‚Äôt. The original gist is <a href="https://gist.github.com/rreusser/c673bb3ec5316cf3bd46a18d4777eff3">here</a>. I‚Äôve surely missed a lot of good information. So it‚Äôs not everything, but hopefully it‚Äôs mostly valid information that can save someone else some of the time it took us to discover all of these things. If there‚Äôs something that‚Äôs changed your life (dev-wise), please let me know in the comments section and I‚Äôd be glad to add it to the list!</p><p><em>Update:</em> Great recommendations based on twitter replies/searches (Thanks, <a href="https://twitter.com/sseraphini">sseraphini</a>!):</p><ul><li><a href="https://github.com/yelouafi/redux-saga">redux-saga</a></li><li><a href="https://github.com/gaearon/redux-thunk">redux-thunk</a></li><li><a href="https://github.com/lelandrichardson/react-native-mock">react-native-mock</a></li><li><a href="https://github.com/airbnb/enzyme">enzyme</a></li><li><a href="https://twitter.com/JI/status/728696866343243777">Sentry and Crashlytics</a></li></ul><h2>The thoughts:</h2><p><strong>Set up your environment carefully</strong>: It‚Äôs important to have <em>one</em> canonical source of truth per environment, per platform. (i.e. iOS Development, iOS Testflight, iOS Production, ditto Android.) Every time you build, your config should propagate values from one input source (per env) to either Java/JavaScript or Objective-C/JavaScript. <a href="https://gist.github.com/rreusser/77c18ca38a6848876c22a00d3fed99a9">Here‚Äôs what we did for Android</a> and <a href="https://gist.github.com/rreusser/283e032fb1bb5f59256fd5b96f8b8e6c">here‚Äôs what we did for iOS</a>. I don‚Äôt doubt that you can do better. <em>Please do better.</em> But you can‚Äôt say that we didn‚Äôt have one canonical source of truth that worked very simply and effectively throughout the development process.</p><p><strong>Don‚Äôt wait until the end to develop Android and iOS concurrently:</strong> Even if you‚Äôre not actively focusing on both platforms, don‚Äôt assume that ‚ÄúRN is cross platform‚Ä¶ we can develop iOS and flip the Android switch when we‚Äôre done.‚Äù It‚Äôs mostly cross-platform. But there‚Äôs lots of little stuff like iOS and Android handling margins on text differently. Small quirks, but not the sort of stuff you want to completely refactor at the end.</p><p><strong>Use a linter:</strong> I like <a href="https://github.com/Flet/semistandard">semistandard</a>. We ran into lots of frustrating issues where we had duplicate keys in hashes that didn‚Äôt fail until we moved to the web platform. A linter can be annoying, but it‚Äôs not so bad if you get on board early. Prevents you from doing lots of stupid invalid stuff that doesn‚Äôt actually cause errors.</p><p><strong>Learning Redux</strong>: If you use it. It was useful to read the source itself. It‚Äôs actually relatively concise. <a href="https://gist.github.com/gaearon/1d19088790e70ac32ea636c025ba424e#file-connect-js">Here‚Äôs Dan Abramov deconstructing it</a>. It helped clear up my understanding of what‚Äôs going on. Understanding exactly why components get updated helped us improve performance dramatically. <a href="https://github.com/reactjs/react-redux/blob/master/src/components/connect.js#L283">I think these are the lines that do it in redux</a>. (<em>&lt;-- fixed this link because hadn‚Äôt looked at this in a while and so didn‚Äôt look deep enough</em>). As for connecting components, we debated whether to connect giant parts of the state tree or lots of little values. Also whether to connect tons of little components or just the big components. Short answer: understand why things get re-rendered and a happy medium is probably best because either extreme has tradeoffs. Connecting <strong>every</strong> component seems silly and expensive, and it‚Äôs probably overkill and unnecessarily verbose to unpack tons of values in every <code>mapStateToProps</code>. Happy medium, I think.</p><p><strong>But what‚Äôs the right data store???</strong> <em>The right data store is one that you understand.</em> We stored our stuff in some weird key-value store (for historical reasons, a glorified <code>{users: {...}, ...}</code> object). It worked pretty well, but what would have made it better would have been either to understand better what triggers updates from the start or maybe to take the plunge and get on board with immutablejs from the start. But there‚Äôs no one true answer. Ours worked fine. If you use a library for your datastore, mainly try to understand <em>why</em> it does what it does (which doesn‚Äôt necessarily include worrying about the internal workings). So just pick one. Don‚Äôt worry. <a href="http://techcrunch.com/2014/10/18/you-too-may-be-a-victim-of-developaralysis/">You‚Äôll be fine</a>.</p><p><strong>Put <code>console.logs</code> in your render statements and figure out just how often things are getting rendered.</strong> You can get away with a lot for a while using react. It‚Äôs magic. Until it feels laggy. The second major release of our iOS app was mainly a giant audit of why there was so much extra rendering going on. Performance increased dramatically.</p><p><strong>Follow people on twitter:</strong> <a href="https://twitter.com/dan_abramov">@dan\_abramov</a>, <a href="https://twitter.com/JI">@JI</a>, <a href="https://twitter.com/ReactJSNews">@ReactJSNews</a>, <a href="https://twitter.com/Vjeux">@Vjeux</a>. Lots more. A good way to be a fly on the wall and find out about trendy stuff without getting sucked into a hacker-news sort of rabbit hole.</p><p><strong>React universal template</strong> The future is upon us. Web, iOS, Android, Server. One codebase. And Windows Phone, soonish. <a href="https://github.com/este/este">este/este.js</a></p><p><strong>My template</strong> which isn‚Äôt great but maybe has a couple things going for it regarding redux + immutable setup. Generally speaking, don‚Äôt just copy the setup blindly though. Understand it. <a href="https://github.com/rreusser/react-native-with-everything">react-native-with-everything</a></p><p><strong>Live on the bleeding edge</strong>: It‚Äôs a calculated risk when you‚Äôre trying to run a business, but we never got bitten by upgrading early and often. On the contrary, the bugfixes and frequent updates prevented our code from getting stale. It meant submitting lots of little PRs to different repos, but it was time well spent. When the community indicates the direction they‚Äôre going, take a hint. So yeah, it‚Äôs probably all NavigatorExperimental moving forward.</p><p><strong>This stuff is outstanding</strong>:</p><ul><li><a href="https://github.com/oblador/react-native-animatable">oblador/react-native-animatable</a></li><li><a href="https://github.com/oblador/react-native-vector-icons">oblador/react-native-vector-icons</a></li></ul><p><strong>Corollary</strong>: <a href="https://icomoon.io/">icomoon.io</a> is the best thing ever for managing icons.</p><p><strong>We didn‚Äôt do much testing.</strong> There. I said it. We didn‚Äôt do much testing. It felt horrible. I‚Äôm embarrassed. There are some little unit tests for tricky logic, and the server-side code has pretty good coverage, but there‚Äôs not really any mobile integration testing. Honestly, good redux middleware made debugging and reasoning about state so easy that there was just never a time when it was a top priority to lock down functionality with tests before we ripped features out and replaced them. We had a couple minor regressions, but 80% of the challenges we had were obscure, untestable things like a weird layering bug with the twitter native share dialog. (And once we hooked up <a href="https://microsoft.github.io/code-push/">CodePush</a>, we could <a href="https://www.youtube.com/watch?v=O_HyZ5aW76c">do it live</a> anyway.) That said, you should always test your code. üòäüëçüèº</p><p><strong>Keyboard spacer</strong>: I <em>highly</em> recommend a single keyboard spacer at the bottom of your top-level view. Or at least very few as high up in the DOM as possible. No need to add them all over the place (it‚Äôs a mess), and best to avoid fixing the height of anything to the height of the viewport (Android and the in-call status bar will make your life unpleasant).<a href="https://www.npmjs.com/package/react-native-keyboard-spacer">react-native-keyboard-spacer</a></p><p><strong>Steer clear of negative margins.</strong> On iOS it‚Äôs the same useful trick you web devs are used to. On Android (unless there‚Äôs a trick I wasn‚Äôt able to find), they all get clipped. If you want content to sit outside its parent container, use a larger parent container with <a href="http://facebook.github.io/react-native/docs/view.html#pointerevents">`pointerEvents=‚Äúbox-none‚Äù`</a>.</p><p><strong>Margins and padding on text components</strong> more or less don‚Äôt have much of an effect on Android, so really try to avoid them if you start with iOS!</p><p><strong>Higher order components</strong> (enhancing behavior without mixins or class inheritance):<a href="https://gist.github.com/sebmarkbage/ef0bf1f338a7182b6775">https://gist.github.com/sebmarkbage/ef0bf1f338a7182b6775</a></p><p><strong>This is useful</strong>: Premature optimization is bad, but good to get a handle on what optimization means: <a href="https://github.com/garbles/why-did-you-update">garbles/why-did-you-update</a></p><p><strong><a href="https://facebook.github.io/react/blog/2015/10/07/react-v0.14.html#stateless-functional-components">Stateless functional components</a></strong>: Good for components that can have no internal state.</p><pre style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code><span style="color:#c678dd">var</span> Button = <span>(<span>props</span>) =&gt;</span> {
  <span style="color:#c678dd">return</span> &lt;View&gt;&lt;Text&gt;{props.label}&lt;/Text&gt;&lt;/View&gt;
}</code></pre><p><strong>But be careful with those because:</strong> An interesting discussion on avoiding re-rendering the entire app on every state update: <a href="https://medium.com/@esamatti/react-js-pure-render-performance-anti-pattern-fb88c101332f#.u3tqgdf47">Pure Render Performance Anti-Pattern</a></p><p><strong>Or just forget understanding optimization and use this:</strong> üòÑ</p><ul><li><a href="https://github.com/thejameskyle/babel-react-optimize">thejameskyle/babel-react-optimize</a></li></ul><p><strong>A trivial optimization that may actually be noticable</strong>:</p><p>Instead of this:</p><pre style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code><span style="color:#c678dd">return</span> &lt;TextInput onChange={() =&gt; { do something inline}}/&gt;</code></pre><p>Do this:</p><pre style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code>_handleChange = <span><span>()</span> =&gt;</span> {
  same thing but not inline
};

render () {
  <span style="color:#c678dd">return</span> &lt;TextInput onChange={this._handleChange}/&gt;
}</code></pre><p>Subtle, but (and thanks, Scott Kyle for correcting my obvious oversight on this one!!) in the first version, the <code>TextInput</code> gets a new callback every time and so gets re-rendered. The second passes the reference to the same callback, hence no re-render.</p><strong>Rendering arrays:</strong><p>Except for the final <code>render</code> which needs to return a single node, you can always deal with arrays of keyed nodes instead of jamming everything together into wrapper views all over the place, e.g.:</p><pre style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code>renderSomePart = <span><span>()</span> =&gt;</span> {
  <span style="color:#c678dd">return</span> [
    &lt;View key=&quot;item-1&quot;/&gt;,
    &lt;View key=&quot;item-2&quot;/&gt;
  ];
};</code></pre><p>Or:</p><pre style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code>renderItem = <span>(<span>item, i</span>) =&gt;</span> (
  &lt;View key=`item-${i}`&gt; ... &lt;/View&gt;
)

renderSomePart = <span><span>()</span> =&gt;</span> {
  <span style="color:#c678dd">return</span> <span style="color:#c678dd">this</span>.props.someDataItems.map(<span style="color:#c678dd">this</span>.renderItem);
};</code></pre><p>And text nodes can contain other text nodes. Our first attempt at a paragraph with mentions was to split text by whitespace and lay out nodes with flexbox. That‚Äôs crazy. You can just nest text nodes and make some of them pressable. Sounds obscure, but it wasn‚Äôt immediately obvious, and if you need it, it‚Äôs life-changing.</p><pre style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code>render () {
  <span style="color:#c678dd">return</span> &lt;View&gt;{[
    &lt;Text key=&quot;1&quot;&gt;Hello, &lt;/Text&gt;,
    &lt;Text key=&quot;2&quot;&gt;{[
      &lt;Text key=&quot;3&quot; onPress={...}&gt;this is a link&lt;/Text&gt;,
      &lt;Text key=&quot;4&quot;&gt;, and this is just regular text&lt;/Text&gt;
    ]}&lt;/Text&gt;
  ]}&lt;/View&gt;;
}</code></pre><p><strong>Loading overlays and z-ordering:</strong>
Absolutely position the overlay top/right/left/bottom: 0 and make sure it‚Äôs <em>after</em> the rest of the content it needs to overlay. Draw order is last-on-top:</p><pre style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code>&lt;View&gt;
  &lt;...&gt;
  &lt;LoadingOverlay&gt;
&lt;/View&gt;</code></pre><p><strong>Android installation (Genymotion)</strong>
Ommitted for brevity, but you can see it in the original gist <a href="https://gist.github.com/rreusser/c673bb3ec5316cf3bd46a18d4777eff3">here</a>. Android Studio 2.0 seems better these days though. Great emulator.</p><h2>Conclusion</h2><p>That‚Äôs all for now! At the end here, I‚Äôm clearly kinda scraping the bottom of the barrel. There‚Äôs nothing profound here, but talking to new React Native devs made me realize how much time we could have saved if someone had been there to walk us through a few basics and warn us ahead of time where we‚Äôd dig the deepest holes for ourselves. Overall we had nothing but good fortune to have taken a gamble and found ourselves working among an oustanding, welcoming, active community of developers. If you need a mobile platform, I highly recomend that you <a href="http://facebook.github.io/react-native/">give it a try!</a></p></div><footer class="footer"><div class="footer__content"><div class="footer_copy">¬© 2020 Ricky Reusser</div></div></footer></div></div></div>
    <script src="index.js"></script>
  </body>
</html>
